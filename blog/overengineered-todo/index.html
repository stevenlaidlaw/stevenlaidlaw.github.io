
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/fonts/stylesheet.css" />
    <link rel="stylesheet" href="/main.css" />
    <title>Learn Docker via an Over-engineered Todo</title>
  </head>
  <body>
    <div class="main">
      <h1>Learn Docker via an Over-engineered Todo</h1>
<p>Learning new stuff is hard, so today I'm going to guide you through using Docker by over-engineering the hell out of Todo app. We will build a three-tier, RESTful web app running multiple containers. You know, like a normal person would.</p>
<blockquote>
<p><strong>Disclaimer:</strong> All the commands here will assume you're running Linux. If you're not, then substitute the commands for your OS.</p>
</blockquote>
<h2>The Specification</h2>
<p>First we need to lay out the spec to make sure we know what we're building. For a standard three-tier app we'd need three separate containers that spoke to each other: the DB, the server, and the app.</p>
<p>For these I chose to use Postgres, Express, and React, respectively, but those technologies aren't the point of this article and can be replaced with anything you need. I'll include some of that code just so you understand what is going on, but won't go deep into detail on them.</p>
<p>The complete code is available in a link to my GitHub at the end of the article, so if you're interested in that part (or making fun of me for bad code) then feel free to peruse.</p>
<p>In any case, here is the basic spec I came up with:</p>
<ol>
<li>Database container automatically initialise with relevant structure.</li>
<li>Express server with the following RESTful endpoints:
<ol>
<li><strong>GET</strong> <code>/todo</code> - List all todos</li>
<li><strong>POST</strong> <code>/todo</code> - Insert a new todo</li>
<li><strong>PATCH</strong> <code>/todo/:id</code> - Update the relevant todo</li>
</ol>
</li>
<li>React app that consumes the endpoints to update the database.</li>
</ol>
<p>So it's a weak spec. I'm not a Product Manager, sue me, but it serves our purpose.</p>
<blockquote>
<p><strong>Note:</strong> You might notice there is no DELETE endpoint. This is deliberate, as it's been drilled into me never to delete user data. Instead we will flag items as deleted in the database.</p>
</blockquote>
<p>So let's create our directory structure:</p>
<pre><code class="language-bash">mkdir -p overengineeredTodo/{app,db,server} &amp;&amp; cd overengineeredTodo
</code></pre>
<h2>The Database Container</h2>
<p>First we need to create the database which will persist our Todos. This is one of the simplest parts of Docker as containers for all your standard databases already exist. Whatever you're familiar with there is very likely to be a container for you. As I'm using Postgres we just need two files:</p>
<ol>
<li>The Dockerfile</li>
<li>The DB init SQL file</li>
</ol>
<p>Let's create them:</p>
<pre><code class="language-bash">touch Dockerfile todo-init.sql
</code></pre>
<p>The <code>Dockerfile</code> file is what tells Docker what you want it to do and thanks to the pre-existing containers are really simple to use. Open it up in your editor of choice and enter the following line:</p>
<pre><code class="language-Dockerfile">FROM postgres:9.5
ENV POSTGRES_DB tododb
COPY todo-init.sql /docker-entrypoint-initdb.d/
</code></pre>
<p>Boom. That's it. Using just that first line you can have a running, containerised instance of Postgres 9.5 running on your machine. The second is an optional environment variable to rename the database from the default. I've called it &quot;tododb&quot;, but you can call it whatever you want. The third is a bit of Postgres specific magic that will allow us to run some SQL when the container is first initialised. Any files (you can have multiple) that are copied over to <code>/docker-entrypoint-initdb.d/</code> will be run automatically. For more information about Postgres entrypoints, see the Docker Hub documentation <a href="https://hub.docker.com/_/postgres/">here</a>.</p>
<p>Of course now we need to fill that file with data, so let's open up <code>todo-init.sql</code> and enter our database structure inside:</p>
<pre><code class="language-sql">create table todo (
	id serial primary key,
	label varchar(256),
	complete boolean default false,
	deleted boolean default false,
	updated_date timestamp default current_timestamp
);
</code></pre>
<p>Here we're setting an id, a label, two flags for whether the todo is complete or deleted, and a timestamp for when the item was last updated. That's really all we need to do for the database.</p>
<h2>The Server Container</h2>
<p>We won't go into full detail on the server as it's all specific to Express and Postgres, but you can view the relevant files in my <a href="https://github.com/stevenlaidlaw/OverengineeredTodo/blob/master/server/server.js">GitHub, here</a>. There are just some things to take note of relating to Docker that I'd like to call attention to:</p>
<ol>
<li>Use environment variables for all the DB and server information.</li>
<li>CORS. We have to make sure to use CORS, as the separate containers are cross-origin.</li>
</ol>
<p>Now run the commands to create the package.json file and install the required dependencies:</p>
<pre><code class="language-bash">npm init &amp;&amp; npm i -S express body-parser cors pg-promise
</code></pre>
<p>We also want to modify the scripts in package.json to allow the container to run it:</p>
<pre><code class="language-js">{
	...
	&quot;scripts&quot;: {
		&quot;start&quot;: &quot;node server.js&quot;
	}
	...
}
</code></pre>
<p>Once this is set up you can go ahead and create another <code>Dockerfile</code> file in the server directory. We'll go through this one a few lines at a time as it's the most complex of the three.</p>
<pre><code class="language-Dockerfile">FROM node:8
WORKDIR /usr/src/app
</code></pre>
<p>First we set the base container to be node 8 so that we can run the express server and set the working directory to <code>/usr/src/app</code>. This will determine where all the files we copy from this point on end up in the container's filesystem.</p>
<pre><code class="language-Dockerfile">COPY package*.json ./
RUN npm install
</code></pre>
<p>Now we copy over the package files and then use the <strong>RUN</strong> command to install the relevant dependencies. <strong>RUN</strong> is a build step in the image, and you can have as many of those as you like. We include the wildcard in <strong>COPY</strong> to make sure we transfer over the <code>package-lock.json</code> file too.</p>
<pre><code class="language-Dockerfile">COPY server.js ./
CMD [ &quot;npm&quot;, &quot;start&quot; ]
</code></pre>
<p>Now we copy over the actual server file, and then run it! Here we use <strong>CMD</strong>, which describes what the container executes when you launch it. There can only be one <strong>CMD</strong>.</p>
<h2>The Application Container</h2>
<p>For ease of use I used 'create-react-app' for this, but you can use whatever you like. Here I made a choice to run the builds locally and then copy over the built files to the Docker image. This is a judgement call, as you can just as well copy over the package.json files and run the build as part of the Dockerfile using the <strong>RUN</strong> command (just like our server did).</p>
<p>As with the server file I won't go into full detail in this post, but you can find the full application logic <a href="https://github.com/stevenlaidlaw/OverengineeredTodo/blob/master/app/src/App.js">here</a>. It's a fairly basic todo app written in React.</p>
<pre><code class="language-Dockerfile">FROM nginx
COPY build /usr/share/nginx/html
</code></pre>
<p>First we use the base 'nginx' image to use as our webserver, and then copy over the build output. We will ensure that the build folder always contains the latest build by adding it to our build step.</p>
<h2>Bringing it all together</h2>
<p>Now that all the individual container images are configured we can use Docker Compose to orchestrate it. Docker Compose is a tool for defining and running multi-container applications, so it's exactly what we need here! Drop back to the base <code>overengineeredTodo</code> directory and run the following command:</p>
<pre><code class="language-bash">touch docker-compose.yml
</code></pre>
<p>This will create a configuration file for us to define how the containers should be brought up. First I'll dump the whole file here, and the we'll go through each command and what it does.</p>
<pre><code class="language-yaml">version: '2.1'
services:

  app:
    build: 'app'
    restart: on-failure
    ports:
      - 8888:80

  db:
    build: 'db'
    restart: on-failure
    ports:
      - 5444:5432
    healthcheck:
      test: [&quot;CMD-SHELL&quot;, &quot;pg_isready -h localhost -U postgres&quot;]
      interval: 10s
      timeout: 5s
      retries: 20

  server:
    build: 'server'
    restart: on-failure
    ports:
      - 8889:8889
    environment:
      - DB_HOST=localhost
      - DB_PORT=5444
      - DB_NAME=tododb
      - DB_USERNAME=postgres
      - DB_PASSWORD=postgres
      - API_HOST=localhost
      - API_PORT=8889
    network_mode: 'host'
    depends_on:
      db:
        condition: service_healthy
</code></pre>
<p>First we set the <code>version</code>. This tells us which format the docker-compose file should take. I'm personally using 2.1 as it's the one I'm most familiar with, but if you're starting a new project you should use the latest which, at time of this writing, is 3.7.</p>
<p>Next we build the services. These can be named whatever you like. Common to each service are a few commands.</p>
<h3>Common Commands</h3>
<p>First is the <code>build</code> command, which is a path to a directory that contains a <code>Dockerfile</code>. This tells Compose where to find the images for building.</p>
<p>The next shared command is <code>restart</code>, which I've set to <code>on-failure</code>. This ensures the containers restart themselves if there are any issues.</p>
<p>The last common command is <code>ports</code>, which maps the relevant ports for each container.</p>
<p>For the ports I've done a few different things. On <code>app</code> I've remapped port 80 to 8888. This is for development purposes, and would likely just stay on port 80 in a live deployment environment. Similarly, I've remapped the default postgres port (5432) to <code>5444</code>. This isn't necessary at all, but I've got various other postgres containers running on my machine, so that's what you're stuck with.</p>
<h3>Unique Commands</h3>
<h4>healthcheck</h4>
<p>This command is used to check on the health of the container and determine whether it's ready for operation. This is important for the database as if we attempt to bring up the <code>server</code> container before postgres is ready then it will crash. To implement this we pass the following arguments:</p>
<ol>
<li><strong>test</strong>: The command to run on the container to determine the health. Arguments are provided as a comma-separated array.</li>
<li><strong>interval</strong>: This determines how long the container will wait to run the check, and then the interval thereafter. Default is <code>30s</code>.</li>
<li><strong>timeout</strong>: How long the test should run before timing out. Default is <code>30s</code></li>
<li><strong>retries</strong>: How many attempts to make before giving up and considering the container <code>unhealthy</code>. Defaults to <code>3</code>.</li>
</ol>
<h4>environment</h4>
<p>Pretty self explanatory, these are the environment variables we'd like the container to receive. Here we pass in all the API and DB information we need for the server to run.</p>
<h4>network_mode</h4>
<p>This changes the network mode that the container runs in. We've switched it to <code>hosts</code> here to ensure that it allows incoming connections from other containers.</p>
<p>Note that when setting the <code>network_mode</code> to 'host' you are unable to map any ports.</p>
<h4>depends_on</h4>
<p>This is where we link back to the <code>healthcheck</code> command that we set up in the <code>db</code> container. This command tells us to wait until the <code>db</code> is healthy before running the container. This ensures the database is ready to accept connections.</p>
<hr>
<p>Of course there are many more commands are your disposal for a variety of setups. The full list of Docker Compose commands, and their available arguments, are available <a href="https://docs.docker.com/compose/">here</a>.</p>
<h2>Bringing it all up</h2>
<p>Now we're ready to launch! Now if you jump into the <code>overengineeredTodo</code> directory and run the following commands:</p>
<pre><code class="language-bash">docker-compose up -d
</code></pre>
<p>This builds the images and brings the containers up. The <code>-d</code> command detaches the containers so we aren't getting the output of them streamed to the console. If you followed the steps you should now be able to visit your app at http://localhost:8888. If you used my project it should look something like this:</p>
<p><img src="https://github.com/stevenlaidlaw/OverengineeredTodo/blob/master/overengineeredTodo.png?raw=true" alt="App demo"></p>
<p>Try changing a few things then refresh the page. You'll see your changes have persisted to the database, and will continue to be available for the lifetime of the container.</p>
<p>Some more helpful commands:</p>
<pre><code class="language-bash"># Build the images
docker-compose build
# Start the containers
docker-compose start 
# Stop the containers
docker-compose stop 
# Stop and destroys the containers
# Be careful as you'll lose your DB data!
docker-compose down
# Get the status of the relevant containers
docker-compose ps
</code></pre>
<hr>
<p>Hopefully this <em>very</em> basic introduction has shed some light on Docker and how to use it in a real world app. Don't forget to add the build step for <code>app</code> before running the <code>docker-compose</code> command to ensure your files are the most up-to-date. You can see the way I've done it in the scripts section of my <code>package.json</code> file <a href="https://github.com/stevenlaidlaw/OverengineeredTodo">here</a>.</p>
<p>That's it! Please let me know if you have any questions or corrections to any of the information here.</p>

    </div>
  </body>
</html>
