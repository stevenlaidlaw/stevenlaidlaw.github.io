
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/fonts/stylesheet.css" />
    <link rel="stylesheet" href="/main.css" />
    <title>Creating a Widget Wrapper with React&#39;s createPortal</title>
  </head>
  <body>
    <div class="main">
      <h1>Creating a Widget Wrapper with React's createPortal</h1>
<p>React is pretty sweet. It works in a nested, hierarchical way—which is awesome in most cases—but sometimes that can cause issues. Sometimes you need something to jump out of the parent container, like a modal dialog or a menu. This is precisely what React's <code>createPortal</code> is used for!</p>
<p>The problem you'll run into though is that when creating a menu or other kind of dropdown, you need to be aware of the parent container's location and display the floating element appropriately positioned on the page. We also need to make sure that we don't fall outside the bounds of the page.</p>
<p>So, without any further ado, let's create a wrapper that we can use for any kind of dropdown we'd ever need!</p>
<h2>The Setup</h2>
<p>First lets create a dumb use-case that will enable us to use this wrapper. We'll build a wide help button that shows a tooltip and stick it in various locations around the page.</p>
<p><a href="https://gist.github.com/stevenlaidlaw/bc8e85166194340c69282e0ae6e46e39">This code</a> gives us the following page, with all the info panels toggled on:</p>
<p><img src="/images/react-widget-portal-0.png" alt="Info Pane Bad"></p>
<p>As you can see the info boxes are currently trapped inside the container, so what we want to do is break it out of the regular DOM hierarchy.</p>
<h2>The Basic Widget</h2>
<p>First let's create the most basic version of the widget. This should render whatever children we pass in using the <code>createPortal</code> method.</p>
<pre><code class="language-jsx">class WidgetPortal extends React.Component {
	constructor(props) {
		super(props);
		// Grab the document root to append the modal to it
		this.documentRoot = document.getElementById('root') || document.body;

		// Create the modal Element
		this.el = document.createElement('div');
		this.el.style.zIndex = '10000';
		this.el.style.position = 'absolute';
	}

	componentDidMount() {
		this.documentRoot.appendChild(this.el);
	}

	render() {
		return ReactDOM.createPortal(this.props.children, this.el);
	}
}
</code></pre>
<p>As you can see in the constructor we first get the root element, then create the modal element using <code>document.createElement</code>. After the component has mounted we then append the element to the root element. In the render method we then use the <code>ReactDOM.createPortal</code> method. This takes two arguments — first the child you'd like to render and next the container element to render to. Here we pass in the children and the element we created earlier.</p>
<p>We can now use this WidgetPortal to wrap the notes portion of our original code.</p>
<pre><code class="language-jsx">&lt;WidgetPortal&gt;
	&lt;div className=&quot;info&quot; onClick={this.onToggle}&gt;
		This is the tooltip for {label}
	&lt;/div&gt;
&lt;/WidgetPortal&gt;
</code></pre>
<p>And we get the following result:</p>
<p><img src="/images/react-widget-portal-1.png" alt="Info Pane Better"></p>
<p>This is better, but still isn't 100% correct and is quite buggy. We can see the whole tooltip now, but it's always up in the top left of the screen and all the tooltips overlap each other. Let's work on first getting the tooltips to sit themselves underneath the buttons like you'd expect.</p>
<h2>Widget Portal Improved</h2>
<p>First we need to wrap the returned value from the render method in a div and create a reference to it. We do this so that we have something still within the natural flow of the page to reference our position from.</p>
<pre><code class="language-jsx">constructor(props) {
	...
	this.ref = React.createRef();
	...
}
</code></pre>
<p>And then wrap the render method to use the new Ref.</p>
<pre><code class="language-jsx">render() {
	return &lt;div ref={this.ref}&gt;
		{ReactDOM.createPortal(this.props.children, this.el)}
	&lt;/div&gt;;
}
</code></pre>
<p>Now for the fun part! We have a reference to a wrapper container that we can use as the basis for the location of the portal element. Let's do that now.</p>
<pre><code class="language-jsx">componentDidMount() {
	...

	const {
		top: containerTop,
		left: containerLeft,
		width: containerWidth,
		height: containerHeight
	} = (this.ref.current.getBoundingClientRect &amp;&amp; this.ref.current.getBoundingClientRect()) || {};

	const containerXCenter = containerLeft + (containerWidth / 2);

	const {width, height} = (this.el.getBoundingClientRect &amp;&amp; this.el.getBoundingClientRect()) || {};

	let top = containerTop + containerHeight;
	let left = containerXCenter - (width / 2);

	this.el.style.top = `${top}px`;
	this.el.style.left = `${left}px`;
}
</code></pre>
<p>Note that we're getting the center point so we can place the element in a more logical way.</p>
<p>With this done we get the following:</p>
<p><img src="/images/react-widget-portal-2.png" alt="Info Pane Almost There"></p>
<p>Yay, it's now positioning correctly! The downside is it's running off the side of the page again, so let's fix that up now. To do this all we need to do is get the edges of the page and force the element to stay within it.</p>
<h2>Widget Portal Complete</h2>
<p>First I like to add a little buffer so it's not flat up against the edge of the page, so add this to the constructor:</p>
<pre><code class="language-jsx">this.BUFFER = 4;
</code></pre>
<p>Next let's modify the componentDidMount function to take into account the page width and height. First grab the data we need based on the dimensions of the HTML:</p>
<pre><code class="language-jsx">const documentHeight = document.documentElement.clientHeight;
const documentWidth = document.documentElement.clientWidth;
</code></pre>
<p>Next, after getting the container and portal dimensions we set all the absolute position values of the element:</p>
<pre><code class="language-jsx">let top = containerTop + containerHeight;
let bottom = documentHeight - (top + height);
let left = containerXCenter - (width / 2);
let right = documentWidth - (left + width);
</code></pre>
<p>Lastly we need to make sure none of these elements fall outside the screen (and buffer), and if they do force them in.</p>
<pre><code class="language-jsx">if (right &lt; this.BUFFER) {
	this.el.style.right = `${this.BUFFER}px`;
} else {
	this.el.style.left = `${left &lt; this.BUFFER ? this.BUFFER : left}px`;
}
if (bottom &lt; this.BUFFER) {
	this.el.style.bottom = `${this.BUFFER}px`;
} else {
	this.el.style.top = `${top &lt; this.BUFFER ? this.BUFFER : top}px`;
}
</code></pre>
<p>As you can see all we're doing is setting either the right/left and bottom/top absolute positions to make sure they sit within the bounds of the screen. You can see the result of this as so:</p>
<p><img src="/images/react-widget-portal-3.png" alt="Info Pane Success"></p>
<p>Success! The tooltips now all sit within the bounds of the page, and always will based on the size of whatever portal you throw at it. Well, as long as the portal itself isn't larger than the page, but that would just be silly, right?</p>
<p>Just to make it clear how it all works I'll post the whole <code>componentDidMount</code> here with comments so you can see how all the parts work together.</p>
<pre><code class="language-jsx">componentDidMount() {
	// Get the document height and width which this portal is added to
	const documentHeight = document.documentElement.clientHeight;
	const documentWidth = document.documentElement.clientWidth;

	// Place the modal Element into the root DOM node
	this.documentRoot.appendChild(this.el);

	// Get the size of the portal container
	const {
		top: containerTop,
		left: containerLeft,
		width: containerWidth,
		height: containerHeight
	} = (this.ref.current.getBoundingClientRect &amp;&amp; this.ref.current.getBoundingClientRect()) || {};

	// Get the container's center point on the X-axis for positioning the element correctly
	const containerXCenter = containerLeft + (containerWidth / 2);

	// Get the size of this portal element
	const {width, height} = (this.el.getBoundingClientRect &amp;&amp; this.el.getBoundingClientRect()) || {};

	// Position the sides of the element from the respective sides of the screen
	let top = containerTop + containerHeight;
	let bottom = documentHeight - (top + height);
	let left = containerXCenter - (width / 2);
	let right = documentWidth - (left + width);

	// Position the element correctly based on the center of the base of the parent element
	// Ensure the Element doesn't fall off the right of the screen
	if (right &lt; this.BUFFER) {
		this.el.style.right = `${this.BUFFER}px`;
	} else { // Or the left
		this.el.style.left = `${left &lt; this.BUFFER ? this.BUFFER : left}px`;
	}
	// Ensure the Element doesn't fall off the bottom of the screen
	if (bottom &lt; this.BUFFER) {
		this.el.style.bottom = `${this.BUFFER}px`;
	} else { // Or the top
		this.el.style.top = `${top &lt; this.BUFFER ? this.BUFFER : top}px`;
	}
}
</code></pre>
<p>Before we forget we have to make sure we clean up our references so make sure you do that in the standard React way like so:</p>
<pre><code class="language-jsx">componentWillUnmount() {
	if (!this.el) return;
	this.documentRoot.removeChild(this.el);
}
</code></pre>
<h2>Conclusion</h2>
<p>Now we have a complete and functional widget wrapper that uses React's <code>createPortal</code> to wrap any and all dropdown/modal/popup elements we may need. There are, of course, ways to improve upon this such as: passing in a reference instead of creating one within the portal for a more accurate location; handling correcting the elements position when zoomed in; and more, but I'll leave those as an exercise to the reader. (For a hint on the zoom, look at <code>window.scrollX</code> and <code>window.scrollY</code>)</p>
<p>Thanks for reading, and if you have any questions/corrections please feel free to let me know!</p>

    </div>
  </body>
</html>
