<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[devoid of context - rss feed]]></title><description><![CDATA[the unfiltered ramblings of software engineer Steven Laidlaw]]></description><link>https://stevenlaidlaw.com</link><generator>GatsbyJS</generator><lastBuildDate>Fri, 16 May 2025 09:27:26 GMT</lastBuildDate><item><title><![CDATA[Size doesn't matter]]></title><description><![CDATA[When I started out as a software engineer, I heard a lot of sweeping ideas about how the size of an organization would dictate the work…]]></description><link>https://stevenlaidlaw.com/20250516_size_doesnt_matter/</link><guid isPermaLink="false">https://stevenlaidlaw.com/20250516_size_doesnt_matter/</guid><pubDate>Fri, 16 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;When I started out as a software engineer, I heard a lot of sweeping ideas about how the size of an organization would dictate the work experience. Big companies meant rigid structures, endless meetings, and hierarchies you couldn&apos;t hope to untangle. Small companies meant agility, creative freedom, and direct access to decision-makers. Medium companies were supposed to be a mix of both, but whether it was a good mix or a bad one depended on who you worked for.&lt;/p&gt;
&lt;p&gt;The truth is, the size of an organization doesn&apos;t matter nearly as much as people like to think it does. Whether you&apos;re at a ten person startup or a multinational with thousands of employees, certain things seem to remain constant. Work can be hectic, personalities clash, and yes, bureaucracy will find a way to wrap itself around even the scrappiest group of folks. Why? Because organizations are made of people, and people are, well, people.&lt;/p&gt;
&lt;p&gt;Sure, the problems may scale, and the culture can shift depending on the size, but ultimately, everywhere you go, most people are just doing their best with the resources and constraints placed in front of them. And here&apos;s the kicker: thriving (professionally and personally) isn&apos;t really about organizational size at all. It&apos;s about the people you work most closely with.&lt;/p&gt;
&lt;p&gt;In every organization I&apos;ve joined, the biggest predictor of my day-to-day satisfaction came down to my immediate circle: the coworkers I bounced ideas off, the manager who guided my growth, and the leadership I directly interacted with. When those relationships were healthy, productive, and built on mutual respect, I thrived.&lt;/p&gt;
&lt;p&gt;Think about the undercurrent of office politics. Many people assume that politics get worse in larger companies because there are more stakeholders, more agendas, more potential conflict, right? But even in smaller organizations, I&apos;ve seen similar dynamics play out, just on a different scale. Clashing egos, differences in working styles, and misguided communication aren&apos;t limited by size. They surface anywhere because people, by nature, aren&apos;t perfect communicators, and we all have our own biases and insecurities. The &quot;we&apos;re a family&quot; trope is a lot more common in smaller companies, and in my experience (and that of others based on the memes) it leads to a pretty toxic environment a lot of the time.&lt;/p&gt;
&lt;p&gt;Now, what does this all mean? It&apos;s freeing in a way. Chasing the &quot;perfect-sized company&quot; is pointless because there isn&apos;t one. What actually matters, and what you &lt;em&gt;can&lt;/em&gt; influence, is the quality of your interactions with your peers. Get along well with your coworkers, and suddenly those tough deadlines or endless Zoom meetings aren&apos;t so bad. Build a strong rapport with your manager, and they&apos;re more likely to advocate for your promotion or help you find opportunities to grow. And let&apos;s not forget your skip level, and so on up the chain. These people might not figure into your &quot;day one priorities&quot; when you&apos;re getting settled in a new role, but they&apos;re the ones who shape how decisions are made, including ones about your own career trajectory.&lt;/p&gt;
&lt;p&gt;To be clear, I&apos;m not suggesting that you start networking purely for the sake of climbing the ladder. Genuine relationships aren&apos;t transactional. But the better you understand what drives the people you work with, the easier it becomes to align your goals with theirs, and that goes a long way in making your working life smoother no matter where you are.&lt;/p&gt;
&lt;p&gt;While the size of the organization you work for can certainly shape your experience, it&apos;s not the only determinant of your happiness, growth, or success. Big or small, companies are just groups of people figuring things out as they go. If you can nail the human side of things, like building strong, authentic relationships with your team and those who have the ability to shape your career? You&apos;ll be in a much better position to thrive. Because if you&apos;re not happy at work it doesn&apos;t matter if there are 5 people, or 50k people. You&apos;ll be miserable either way.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Don't be invisible]]></title><description><![CDATA[You know the funny thing about being a software engineer? A lot of us got into this career because we liked the idea of talking to computers…]]></description><link>https://stevenlaidlaw.com/20250515_dont_be_invisible/</link><guid isPermaLink="false">https://stevenlaidlaw.com/20250515_dont_be_invisible/</guid><pubDate>Thu, 15 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;You know the funny thing about being a software engineer? A lot of us got into this career because we liked the idea of talking to computers more than people. Machines are predictable, rational, and (mostly) fair judges of effort. If something isn&apos;t working, the feedback loop is immediate. It&apos;s not subjective. No politics. No office drama.&lt;/p&gt;
&lt;p&gt;And yet, as cozy as that sounds, it&apos;s unrealistic. It turns out the human side (the one we might have been trying to avoid) is just as essential. If you want to thrive in your career, you can&apos;t afford to be invisible.&lt;/p&gt;
&lt;p&gt;Let&apos;s get one thing straight: invisibility isn&apos;t about your physical presence at HQ or how much you talk during meetings. It&apos;s about whether people know who you are, what you do, and why it matters. Because if they don&apos;t, your hard work might as well not exist. So, if the idea of &quot;self-promotion&quot; feels awkward or unnecessary, let&apos;s reframe that. Being visible isn&apos;t about boasting. It&apos;s about ensuring your contributions aren&apos;t lost in the noise.&lt;/p&gt;
&lt;p&gt;Let&apos;s start with glue work. You know, the unsung heroics: code reviews, writing documentation, testing, refactoring, fixing those data migrations no one else wants to touch, performance and accessibility enhancements, etc. These are the things that keep the system together, even if they&apos;re not the splashy features that make it onto a quarterly presentation slide. But here&apos;s the rub: glue work is invisible to most people unless you&apos;re intentional about making it visible. When everything&apos;s running smoothly, people overlook the maintenance it took to get there. If it breaks someone might remember, but by then it&apos;s damage control.&lt;/p&gt;
&lt;p&gt;If you&apos;re quietly refactoring that state manager or writing documentation for onboarding new folks to a project, don&apos;t just silently commit your changes and move on to the next task. Share the backstory with your team or manager. Say, &quot;Hey, that performance slowdown we kept running into was because of XYZ in &lt;code class=&quot;language-text&quot;&gt;StateManager&lt;/code&gt;? I refactored it and added tests to prevent regressions. We&apos;ve gained ABC on our scorecards and should make it easier to expand without issues going forward.&quot; There&apos;s no chest-pounding here, just giving people the context they need to appreciate the value of the work.&lt;/p&gt;
&lt;p&gt;Still, I get it. If you&apos;re introverted or working remotely, this can feel like climbing uphill in the rain. It&apos;s easier to sit back and assume the work will speak for itself, but in reality it rarely does. In the chaos of deadlines, meetings, and Slack notifications, people don&apos;t always notice what isn&apos;t explicitly put in front of them. Visibility takes effort, but it doesn&apos;t mean you have to fundamentally change who you are.&lt;/p&gt;
&lt;p&gt;Here are a few achievable ways to get started:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Document and share your work&lt;/strong&gt;: Going beyond code comments, write up short summaries of what you&apos;ve tackled each sprint. Post in a team channel, write a post (at GitHub we use discussions), or highlight it in a retro.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Be active on pull requests&lt;/strong&gt;: Leave thoughtful comments and reviews (and not just nitpicks about formatting). Engaging in code reviews isn&apos;t just about strengthening the code base, it&apos;s also an avenue to demonstrate your thought process and let people see the quality of your engineering mind.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Speak up during meetings&lt;/strong&gt;: Even remotely, you have opportunities to chime in. If you&apos;ve worked on something relevant or have insights to add, don&apos;t hesitate to share. Even if it&apos;s just a brief, &quot;I wanted to highlight X. we&apos;ve seen improvement in performance since implementing XYZ.&quot; You don&apos;t need to dominate the conversation, just be present in it.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now, beyond making glue work visible, let&apos;s talk about prioritization. If you want to be visible, work that aligns with the organization&apos;s priorities is your ally. If you&apos;re tinkering on side quests nobody has asked for, guess what? No one&apos;s paying attention. What&apos;s worse, when deadlines crush the team or major blockers flare up, that invisibility isn&apos;t going to work in your favor. Focus on initiatives that matter to the broader goals of the team or the company because visibility isn&apos;t just about broadcasting what you&apos;re doing it&apos;s about working on things others care about.&lt;/p&gt;
&lt;p&gt;This doesn&apos;t mean you should drop everything to chase every flashy thing that crosses your desk. That&apos;s a recipe for burnout. But when you have the choice lean toward projects that have a clear impact, lift the team, or make the product demonstrably better. Fix the bug that has bugged QA for the last quarter. Build the feature your customers have been begging for. Do something where the &quot;why&quot; is interesting to your stakeholders. This is especially true if you&apos;re angling for a promotion.&lt;/p&gt;
&lt;p&gt;I know there&apos;s a tendency to roll your eyes at phrases like &quot;stakeholders&quot; or &quot;showing impact&quot; and the like. It sounds corporate. But look, the reality is, software development isn&apos;t about writing code. It&apos;s delivering a product that meets the needs of users. If you want to be recognized for your work, you need to show how it contributes to that goal. And that means being visible about what you&apos;re doing and why it matters.&lt;/p&gt;
&lt;p&gt;It also means choosing the right projects to work on, but that&apos;s a blog post for another day.&lt;/p&gt;
&lt;p&gt;So the next time you think, &quot;They should know what I&apos;m doing,&quot; remember that they probably don&apos;t. And that&apos;s not a failure on their part it&apos;s an opportunity on yours.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[What are you testing?]]></title><description><![CDATA[Writing tests can feel like eating your vegetables. You know it's good for you. You know future-you will thank you. But sometimes you just…]]></description><link>https://stevenlaidlaw.com/20250425_what_are_you_testing/</link><guid isPermaLink="false">https://stevenlaidlaw.com/20250425_what_are_you_testing/</guid><pubDate>Fri, 25 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Writing tests can feel like eating your vegetables. You know it&apos;s good for you. You know future-you will thank you. But sometimes you just don&apos;t want to do it. Or, worse, you do it begrudgingly, rushing gh the task to check it off your list without really stopping to think. We&apos;ve all been there: you write a quick test that lightly prods at the outer shell of your code, pat yourself on the back for covering your bases, and move on. But then a bug slips through, and you&apos;re left wondering, &quot;Didn&apos;t I test for this?&quot;&lt;/p&gt;
&lt;p&gt;Here&apos;s the thing about testing: it&apos;s not just an exercise in covering lines of code or getting your &quot;percent coverage&quot; into the green. Effective tests are about understanding &lt;em&gt;why&lt;/em&gt; you&apos;re testing something and making sure that what you&apos;re testing actually matters. If you&apos;re not asking yourself, &quot;What exactly am I testing here?&quot; before you start, then you&apos;re probably not writing the tests your code really needs. Let&apos;s walk through why this matters and how to ask the right questions.&lt;/p&gt;
&lt;p&gt;First, let&apos;s talk about purpose. What are you trying to achieve with your code? This might seem obvious, but it&apos;s the foundational question you need to answer before typing out test assertions. Tests should validate that your code is doing what it&apos;s supposed to do — not just that it &lt;em&gt;works&lt;/em&gt; in the most obvious way, but that it holds up under the full spectrum of real-world use cases. And while it&apos;s tempting to fall back on default mental heuristics like &quot;test the happy path,&quot; that&apos;s only part of the picture. Sure, test that your perfect scenario works. But what if things aren&apos;t perfect? What if the inputs are weird, unpredictable, or downright wrong? Do you want your code to gracefully fail, throw a descriptive error, or plow ahead obliviously? More importantly, how will you &lt;em&gt;know&lt;/em&gt; that&apos;s what it&apos;s doing? Your tests are where you define and enforce these expectations.&lt;/p&gt;
&lt;p&gt;But the real kicker? You also need to think about what you &lt;em&gt;don&apos;t&lt;/em&gt; need to test. Not all code is created equal when it comes to failure risk. Some parts of your codebase are inherently more prone to breakage, whether due to complexity, external dependencies, or just the fact that they&apos;re actively evolving. Others are so static or trivial that spending time on them isn&apos;t worth your energy. Unless, of course, your organization requires 100% test coverage in a fit of code-aesthetic purity (in which case, my sympathies). Focusing your testing efforts where they will have the highest impact is a time-management superpower. If you wield it correctly, you&apos;ll avoid writing mountains of unnecessary tests that no one will ever look at again.&lt;/p&gt;
&lt;p&gt;Let&apos;s dig into UI testing specifically, because this is a trap I&apos;ve seen more teams fall into than I can count. UI tests are important, don&apos;t get me wrong, but they are also a giant time suck if you let them veer off into the weeds. What&apos;s the number one thing people love to test in UI code? You guessed it: how things look. Did the layout render correctly? Is the button blue? Does the page have the expected text? These are easy things to write tests for, and easy traps to fall into because they &lt;em&gt;feel&lt;/em&gt; like progress.&lt;/p&gt;
&lt;p&gt;But here&apos;s the truth: most users will never care if a button changes from blue to green. What users &lt;em&gt;do&lt;/em&gt; care about is whether clicking that button does the thing it&apos;s supposed to do. Your job as a developer isn&apos;t to protect the aesthetics of the UI, it&apos;s to protect the &lt;em&gt;behavior&lt;/em&gt; of the app. UI tests shouldn&apos;t be about pixels. They should be about outcomes.&lt;/p&gt;
&lt;p&gt;This means approaching UI tests from a state-and-action perspective. Ask yourself: when I interact with the UI, does the underlying state of the application change the way it&apos;s supposed to? If clicking a button fires off a network request and updates a list you don&apos;t need a test to check the the exact layout, what you care about is whether interacting with the UI successfully triggers the state change, processes the response, and updates the list correctly. Anything beyond that is window dressing.&lt;/p&gt;
&lt;p&gt;Which brings me to edge cases. If happy-path testing is like brushing your teeth, edge-case testing is like flossing: so easy to skip, so essential for preventing disaster. Your edge cases are where bugs breed. When inputs are malformed, states are messy, or events cascade unexpectedly, does your code still hold up? You have to embrace the chaos. Test for the things you think could &lt;em&gt;never&lt;/em&gt; happen: extra-long names that break layouts, unsupported file formats, someone mashing buttons like they&apos;re playing a video game on turbo mode. These are the scenarios that will bite you in the ass.&lt;/p&gt;
&lt;p&gt;Finally, think about the lifespan of your tests. No one likes maintenance-mode testing, but the truth is, your tests should grow and adapt just like your code does. Push yourself to ask: what&apos;s likely to change in the future? If a function has volatile business logic, get a test in there. If a critical workflow is prone to iterative updates, lock down its behavior in your suite. Remember, tests are a tool for safekeeping the intentions behind your code as it evolves. They are not sacred documents. Keep them relevant, prune the useless ones, and evolve them alongside your application.&lt;/p&gt;
&lt;p&gt;At the end of the day, testing is a skill, and like all skills, it gets sharper with practice. But it starts with awareness: ask yourself what you&apos;re testing, why you&apos;re testing it, and what matters most in the moment. The more intentional you are, the more value you&apos;ll get — not just from your test suite, but from the confidence you carry into every pull request. Because knowing that your code is doing exactly what it&apos;s supposed to (and nothing it&apos;s not) is a feeling that trumps any arbitrary coverage metric every single time.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Reduce, Reuse, Refactor]]></title><description><![CDATA[Like most software engineers, I've spent most of my career reading other people's code. Between pull requests, tracking down bugs, building…]]></description><link>https://stevenlaidlaw.com/20250118_reduce_reuse_refector/</link><guid isPermaLink="false">https://stevenlaidlaw.com/20250118_reduce_reuse_refector/</guid><pubDate>Sat, 18 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Like most software engineers, I&apos;ve spent most of my career reading other people&apos;s code. Between pull requests, tracking down bugs, building out new features, and just plain old research to learn a code base, there is a lot of time an engineer will sink into trying to understand what other people are thinking.&lt;/p&gt;
&lt;p&gt;Hell, if you’re around long enough you’ve probably come across indecipherable code that a previous version of yourself wrote, and if you’re lucky you’ll have proof of your growth when you cringe at some of it.&lt;/p&gt;
&lt;p&gt;All of this is to say that I’ve come up with a few questions I ask myself when I approach adding new and fixing old code. Things I find helps avoid the classic pitfalls of refactoring “bad” code and making it “clean”.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Is it messy, or is it complex?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Messy and complex are often conflated. It’s the primary impetus behind a lot of unnecessary rewrites — especially when written in a language or framework that you’re unfamiliar with. Particularly when said framework/language is not currently “cool”. No one likes having to learn new things to build a feature that they already know how to build. Besides, that old code is messy as heck! Lots of it is completely unnecessary. You could make this much cleaner and more efficient.&lt;/p&gt;
&lt;p&gt;Sound familiar? Tell me, how much did your stomach drop when you happily deployed your new clean code and now support is inundated with bug reports? What do you mean people on old iPhones can’t load the page anymore? Huh, the layout is broken in Firefox? Why has our accessibility score dropped below an acceptable rating? You&apos;ll discover that most of that &quot;messy&quot; code was written to solve those same bug reports over the last few years. The code wasn&apos;t messy. It was battle-hardened.&lt;/p&gt;
&lt;p&gt;Take those few extra cycles to understand the purpose of something. If you don&apos;t know why it&apos;s there, sure it could be left over from something long removed, but it also could be something you don&apos;t yet know you don&apos;t know. Getting better at recognising this comes down to experience, but at least being aware of it means you&apos;ll be less likely to remove something in future that you don&apos;t understand.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Do I actually have to rewrite this?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;The second best thing a good software engineer does is write code. The best is to delete it. Every line of code added to a codebase contributes to headaches. That code must be tested, understood by others, maintained, and considered for future changes. It is also a potential area for bugs, regressions, security issues, etc. You should always attempt to reduce the amount of code you write in any way possible, and the best way to accomplish this is through code reuse.&lt;/p&gt;
&lt;p&gt;It&apos;s easy to fall into the trap of writing new and clever code, but reusing existing code is always better. This is true both in terms of time spent and code quality. As mentioned above code isn&apos;t messy by default, but because it&apos;s been used and abused over time. You can write some new code that is clean and elegant but it won&apos;t cover all the edge cases and bugs that the messy code has already solved.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;What&apos;s the simplest way I can write this code for future use?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you absolutely must write new code make sure you&apos;re writing as little as possible and that it&apos;s as simple as you can make it. This doesn&apos;t mean being clever -- it means being clear. You always want to write code that is easy to read, understand, and maintain. Chances are you work in a team and might not always be there to show someone how the code works. You have to make it accessible to others, especially those without as much experience as yourself.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Is there something close to this functionality that I can modify to cover both use cases?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Recycling code is when you take existing code and modify it to include your use case without breaking the original purpose. This can be as simple as just a helper file within your codebase or something completely independent like a library (useful when separate services do similar things but comes with issues around maintenance and ownership). Which way you take this is up to your team or organisation to decide.&lt;/p&gt;
&lt;p&gt;Regardless of how you intend to refactor a code base, I hope that you always go in with a few of these things in mind. Remember that no one wants to write bad or messy code. Everyone wants to do their best work but a lot of the time the reality of priorities and deadlines can mean decisions were made at that time that were considered good enough. Generally, the end user doesn&apos;t care about the difference between messy and clean code as long as the functionality is the same. Remember to practice patience and thoughtfulness, and to remain humble, because the next time you&apos;re cursing someone&apos;s bad code you might see your name in the &lt;code class=&quot;language-text&quot;&gt;git blame&lt;/code&gt; column.&lt;/p&gt;</content:encoded></item></channel></rss>