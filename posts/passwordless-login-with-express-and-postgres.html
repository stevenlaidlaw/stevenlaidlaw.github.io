<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Steven Laidlaw</title>
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="robots" content="index,follow" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=League+Spartan:wght@700&family=Roboto+Mono&family=Source+Serif+Pro:ital,wght@0,400;0,700;1,400;1,700&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --color-fg: #e1e3e6;
        --color-bg: #010815;
      }
      body,
      html {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      html {
        background: var(--color-bg);
      }
      body {
        background: repeating-linear-gradient(
          var(--color-bg),
          var(--color-bg) 1px,
          rgba(255, 255, 255, 0.05) 1px,
          rgba(255, 255, 255, 0.05) 2px
        );
        color: var(--color-fg);
        font-family: "Roboto Mono", monospace;
        font-size: 21px;
        display: flex;
        flex-direction: column;
        height: 100hv;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 1em 0;
        text-transform: none;
        font-weight: 700;
      }
      h1 {
        font-size: 2.5em;
      }
      h2 {
        font-size: 2em;
      }
      h3 {
        font-size: 1.5em;
      }
      h4 {
        font-size: 1.25em;
      }
      h5 {
        font-size: 1em;
      }
      h6 {
        font-size: 0.875em;
      }
      p {
        letter-spacing: 0.01em;
        line-height: 1.8em;
        margin: 1em 0;
      }
      a {
        color: cornflowerblue;
        text-decoration: none;
      }
      ol,
      ul {
        line-height: 1.4;
        margin: 0 0 20px;
      }
      ol ol,
      ol ul,
      ul ol,
      ul ul {
        margin: 10px 0 0 20px;
      }
      ol li,
      ul li {
        margin: 0 0 2px;
      }
      ol li:last-of-type,
      ul li:last-of-type {
        margin-bottom: 0;
      }
      blockquote {
        border-left: 4px solid #353638;
        margin: 40px 0;
        padding: 5px 30px;
        opacity: 0.5;
      }

      /*!
        Theme: Dracula
        Author: Mike Barkmin (http://github.com/mikebarkmin) based on Dracula Theme (http://github.com/dracula)
        License: ~ MIT (or more permissive) [via base16-schemes-source]
        Maintainer: @highlightjs/core-team
        Version: 2021.09.0
      */
      pre code.hljs {
        display: block;
        overflow-x: auto;
        padding: 1em;
        font-size: 0.9em;
        border-radius: 0.5em;
      }
      code.hljs {
        padding: 3px 5px;
      }
      .hljs {
        color: #e9e9f4;
        background: #282936;
      }
      .hljs ::selection,
      .hljs::selection {
        background-color: #4d4f68;
        color: #e9e9f4;
      }
      .hljs-comment {
        color: #626483;
      }
      .hljs-tag {
        color: #62d6e8;
      }
      .hljs-operator,
      .hljs-punctuation,
      .hljs-subst {
        color: #e9e9f4;
      }
      .hljs-operator {
        opacity: 0.7;
      }
      .hljs-bullet,
      .hljs-deletion,
      .hljs-name,
      .hljs-selector-tag,
      .hljs-template-variable,
      .hljs-variable {
        color: #ea51b2;
      }
      .hljs-attr,
      .hljs-link,
      .hljs-literal,
      .hljs-number,
      .hljs-symbol,
      .hljs-variable.constant_ {
        color: #b45bcf;
      }
      .hljs-class .hljs-title,
      .hljs-title,
      .hljs-title.class_ {
        color: #00f769;
      }
      .hljs-strong {
        font-weight: 700;
        color: #00f769;
      }
      .hljs-addition,
      .hljs-code,
      .hljs-string,
      .hljs-title.class_.inherited__ {
        color: #ebff87;
      }
      .hljs-built_in,
      .hljs-doctag,
      .hljs-keyword.hljs-atrule,
      .hljs-quote,
      .hljs-regexp {
        color: #a1efe4;
      }
      .hljs-attribute,
      .hljs-function .hljs-title,
      .hljs-section,
      .hljs-title.function_,
      .ruby .hljs-property {
        color: #62d6e8;
      }
      .diff .hljs-meta,
      .hljs-keyword,
      .hljs-template-tag,
      .hljs-type {
        color: #b45bcf;
      }
      .hljs-emphasis {
        color: #b45bcf;
        font-style: italic;
      }
      .hljs-meta,
      .hljs-meta .hljs-keyword,
      .hljs-meta .hljs-string {
        color: #00f769;
      }
      .hljs-meta .hljs-keyword,
      .hljs-meta-keyword {
        font-weight: 700;
      }

      #content {
        padding: 1em;
        max-width: 800px;
      }

      .postLink {
        display: flex;
        align-items: center;
        margin: 1em 0;
        gap: 1em;
        text-transform: capitalize;
        font-size: 0.8em;
      }

      header span,
      footer span,
      .postLink > span {
        opacity: 0.5;
      }

      header {
        padding-left: 1em;
        padding-bottom: 1em;
      }

      header > h3 {
        margin-bottom: 0;
      }

      footer {
        padding: 1em;
        font-size: 0.8em;
      }

      footer > .copy {
        opacity: 0.5;
      }

      footer > .copy > span {
        font-size: 1.5em;
        font-weight: bold;
      }
    </style>
  </head>
  <body>
    <header>
      <h3>&gt; <a href="/">Steven Laidlaw</a></h3>
      <div>Software Engineer <span>//</span> Author</div>
    </header>

    <div id="content"><h1 id="passwordless-authentication-with-express-and-postgresql">Passwordless authentication with Express and PostgreSQL</h1>
<h2 id="table-of-contents">Table of Contents</h2>
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#disclaimer">Disclaimer</a></li>
<li><a href="#overview">Overview</a></li>
<li><a href="#implementation">Implementation</a><ul>
<li><a href="#setup">Setup</a></li>
<li><a href="#database-structure">Database Structure</a></li>
<li><a href="#creating-queries">Creating Queries</a></li>
<li><a href="#html-templates">HTML Templates</a></li>
<li><a href="#api-endpoints">API endpoints</a><ul>
<li><a href="#get-register-login">GET /register, /login</a></li>
<li><a href="#post-register">POST /register</a></li>
<li><a href="#post-login">POST /login</a></li>
<li><a href="#post-token">POST /token</a></li>
<li><a href="#get-account">GET /account</a></li>
<li><a href="#get-logout">GET /logout</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
</ul>
<h3 id="introduction">Introduction</h3>
<p>Static passwords suck. Not only are they a well-known <a href="https://community.jisc.ac.uk/library/janet-services-documentation/passwords-threats-and-counter-measures">security risk</a>, but they are also the <a href="https://www.afr.com/technology/passwords-often-the-weak-link-in-the-security-chain-20180808-h13pf3">weakest part of the chain</a> when determining a user&#39;s authenticity.</p>
<p>Users generally either make them so simple as to be easily guessable, or are reused so often that getting a password cracked in one website means the rest of your accounts are up for grabs. Even power users who use hard to guess randomly generated passwords often are required to use password managers to keep them all in line which introduces another single point of failure.</p>
<p>These problems are so prevalent that most applications these days either mandate or strongly recommend multi-factor authentication. The most common of these is the one-time password that is either emailed to the user or linked to a special device. The recommendation of this article is that you ditch static passwords altogether due to the aforementioned security risks, and simply implement one-time passwords instead.</p>
<p>So why one-time passwords? First of all they&#39;re good for users because they don&#39;t have to remember a password. Just put your email address into the login field and they&#39;ll be sent an auto-generated password or link to log them in. Secondly these passwords are short-lived, which means that if a data breach <em>does</em> happen then there are no active passwords stored for crackers to log in with or share, which reduces the attack window dramatically. As long as a user has access to their email address their accounts will be safe.</p>
<h2 id="disclaimer">Disclaimer</h2>
<p>This article assumes you know your way around PostgreSQL and ExpressJS. We will not be hand-holding you through the entire application build, but instead will be focusing on the concepts and things you&#39;ll need to know to implement a safe and secure one-time password login system.</p>
<p>A complete working example will be available at the end of the tutorial.</p>
<h2 id="overview">Overview</h2>
<p>For this article we&#39;ll be implementing the most simple version of a one-time password (OTP): a short code sent via email. This was chosen for simplicity, availability, and cost. Almost every user will have an email, and there is very minimal cost in sending them compared with something like SMS. A OTP is used here over a link also for user convenience. It allows them to retrieve the code on one device (like a phone) and log into your service on another (like a public computer).</p>
<p>As a high-level overview the implementation will be as follows:</p>
<ul>
<li>A user registers an account using their email address</li>
<li>The user attempts to log in using their email address</li>
<li>The site retrieves the user information and generates a OTP</li>
<li>The OTP is stored securely in the database, and sent via plain text to the user</li>
<li>The user will then retrieve the code and enter it into the login field provided</li>
<li>The OTP is verified against the database</li>
<li>If successful, the user is logged into the application </li>
<li>The OTP is then deleted from the database to prevent re-use</li>
</ul>
<p>This flow is flexible and can be implemented using any technology you are familiar with, but as mentioned we&#39;ll be using PostgreSQL and ExpressJS for this example.</p>
<h2 id="implementation">Implementation</h2>
<h3 id="setup">Setup</h3>
<p>Generate yourself an Express app, and set up your Postgres database. For libraries we&#39;ll be using:</p>
<ul>
<li><a href="https://github.com/brianc/node-postgres">node-postgres</a> for interfacing with our database</li>
<li><a href="https://github.com/auth0/node-jsonwebtoken">node-jsonwebtoken</a> for the JWT</li>
<li><a href="https://github.com/kelektiv/node.bcrypt.js">bcrypt</a> for encrypting the one-time passwords</li>
<li><a href="https://github.com/eleith/emailjs">emailjs</a> for emailing the user</li>
<li><a href="https://github.com/motdotla/dotenv">dotenv</a> for loading our secrets and parameters</li>
</ul>
<p>For our <code>.env</code> file we need the following environment variables in place:</p>
<pre><code class="hljs language-env">## Database connection string
DATABASE_URL=postgresql://username:password@localhost:5432/dbname
## Secret key for secure JWT generation
JWT_SECRET_KEY=ARandomStringOfCharacters0389j0jsdf8jr8h9as8jd
## Email information for sending the one-time passwords
EMAIL_USER=admin@yourapp.com
EMAIL_PASSWORD=TestPassword1
EMAIL_HOST=mail.mailserver.com
EMAIL_FROM=Your App &lt;admin@yourapp.com&gt;
</code></pre>
<blockquote>
<p>Tip: This is not a great way to store secrets in a production app. A secure key store would be more appropriate, but for local development and testing this should be fine.</p>
</blockquote>
<h3 id="database-structure">Database Structure</h3>
<p>Firstly we must initialise our database to allow users to both register and log-in using the one-time password. For that we will need two tables, <code>users</code> and <code>otp</code>. Users must contain at least an id and email address field like so:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> users (
    id <span class="hljs-type">INT</span> GENERATED ALWAYS <span class="hljs-keyword">AS</span> <span class="hljs-keyword">IDENTITY</span>,
    email <span class="hljs-type">varchar</span>(<span class="hljs-number">256</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    <span class="hljs-keyword">PRIMARY</span> KEY(id)
);
</code></pre>
<p>This is a very simple user field which only stores the user&#39;s unique ID and the their email address.</p>
<p>Next we want to create a table to handle the one-time passwords:</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> otp (
    user_id <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    code <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">64</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,
    created_at <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span>,
    <span class="hljs-keyword">CONSTRAINT</span> fk_user <span class="hljs-keyword">FOREIGN</span> KEY(user_id) <span class="hljs-keyword">REFERENCES</span> users(id)
);
</code></pre>
<p>This will store the hashed OTP and the user&#39;s ID as a pair. The <code>created_at</code> column here is also important to ensure that the OTP expires quickly. Time between attempting and completing the login should be minimal for security purposes.</p>
<h3 id="creating-queries">Creating Queries</h3>
<p>Now we need to create some queries to handle the interfacing with the database. At minimum we&#39;ll need the following:</p>
<ul>
<li>Users<ul>
<li>Create</li>
<li>GetByEmail</li>
</ul>
</li>
<li>OTP<ul>
<li>Create</li>
<li>GetByUserId</li>
<li>DeleteByUserId</li>
</ul>
</li>
</ul>
<p>This will enable us to create users, and generate then delete one-time passwords.</p>
<p>Firstly I like to create a function that will run our query, log the attempt and results, and then return the results.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> dotenv = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;dotenv&quot;</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Pool</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;pg&quot;</span>);

<span class="hljs-comment">// Load the environment variables</span>
dotenv.<span class="hljs-title function_">config</span>();
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">DATABASE_URL</span> } = process.<span class="hljs-property">env</span>;

<span class="hljs-comment">// Create a Database pool</span>
<span class="hljs-keyword">const</span> pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pool</span>({
  <span class="hljs-attr">connectionString</span>: <span class="hljs-variable constant_">DATABASE_URL</span>,
  <span class="hljs-attr">ssl</span>: {
    <span class="hljs-attr">rejectUnauthorized</span>: <span class="hljs-literal">false</span>,
  },
});

<span class="hljs-keyword">const</span> <span class="hljs-title function_">runQuery</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">query, ...args</span>) =&gt; {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`DB Request:::[<span class="hljs-subst">${query}</span>]::ARGS::[<span class="hljs-subst">${args.join(<span class="hljs-string">&quot;,&quot;</span>)}</span>]`</span>);
  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> pool.<span class="hljs-title function_">query</span>(query, args);
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(
    <span class="hljs-string">`DB Result:::<span class="hljs-subst">${result.rowLength}</span> results::[<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(result.rows)}</span>]`</span>
  );
  <span class="hljs-keyword">return</span> result.<span class="hljs-property">rows</span>;
};
</code></pre>
<p>Now we can use this function to generate the aforementioned queries like so:</p>
<pre><code class="hljs language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-title class_">Users</span>: {
    <span class="hljs-title class_">Create</span>: <span class="hljs-keyword">async</span> (email) =&gt;
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">runQuery</span>(
        <span class="hljs-string">&quot;INSERT INTO users (email) VALUES ($1, $2)&quot;</span>,
        email
      ),
    <span class="hljs-title class_">Get</span>: {
      <span class="hljs-title class_">ByEmail</span>: <span class="hljs-keyword">async</span> (email) =&gt;
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runQuery</span>(
          <span class="hljs-string">&quot;SELECT id, name, email, active FROM users WHERE email = $1&quot;</span>,
          email
        ),
    },
  },
  <span class="hljs-title class_">Otp</span>: {
    <span class="hljs-title class_">Create</span>: <span class="hljs-keyword">async</span> (user_id, code) =&gt;
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">runQuery</span>(
        <span class="hljs-string">&quot;INSERT INTO otp (user_id, code) VALUES ($1, $2)&quot;</span>,
        user_id,
        code
      ),
    <span class="hljs-title class_">Delete</span>: {
      <span class="hljs-title class_">ByUserId</span>: <span class="hljs-keyword">async</span> (user_id) =&gt;
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runQuery</span>(<span class="hljs-string">&quot;DELETE FROM otp WHERE user_id = $1&quot;</span>, user_id),
    },
    <span class="hljs-title class_">Get</span>: {
      <span class="hljs-title class_">ByUserId</span>: <span class="hljs-keyword">async</span> (user_id) =&gt;
        <span class="hljs-keyword">await</span> <span class="hljs-title function_">runQuery</span>(
          <span class="hljs-string">&quot;SELECT code, created_at FROM otp WHERE user_id = $1&quot;</span>,
          user_id
        ),
    },
  },
};
</code></pre>
<p>Our queries are now ready to use!</p>
<h3 id="html-templates">HTML Templates</h3>
<p>Before we tackle the API endpoints lets quickly throw together some forms for the front-end. We only need three forms to handle everything:</p>
<ul>
<li>Register</li>
<li>Login</li>
<li>Token</li>
</ul>
<p>Here are some examples:</p>
<pre><code class="hljs language-html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/users/register&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter Email&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Register<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/users/login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter Email&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Send Code<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/users/token&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;code&quot;</span>&gt;</span>Code<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;code&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter Code&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;{{email}}&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Login<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>All three form templates are very similar. The only thing to look out for is the hidden <code>email</code> field in the token form. We have to make sure that this field is populated with the email that was submitted from the login/register screen, otherwise the back-end won&#39;t know what user we&#39;re attempting to log in as.</p>
<h3 id="api-endpoints">API endpoints</h3>
<p>So we have our queries, now we can put them to use. We&#39;re going to need six API endpoints in order to cover everything we need for a simple login system:</p>
<ol>
<li><code>/register GET</code> - To serve the register page</li>
<li><code>/register POST</code> - To create a user</li>
<li><code>/login GET</code> - To serve the login page</li>
<li><code>/login POST</code> - To generate a one-time password</li>
<li><code>/token POST</code> - To generate the user session</li>
<li><code>/account GET</code> - To validate the session token</li>
<li><code>/logout GET</code> - To destroy the user&#39;s session</li>
</ol>
<p>We&#39;ll tackle these one at a time to get a feel for how it all works together.</p>
<h4 id="get-register-login">GET /register, /login</h4>
<p>The simplest of all these endpoints are the get endpoints for the Register and Login templates. We just want to render these pages using your view engine of choice.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;login&quot;</span>);
});

router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/register&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;register&quot;</span>);
});
</code></pre>
<p>Usually you&#39;d want to check if the user is logged in on any of these endpoints and redirect them away from the pages if so, but I&#39;ll leave that as an exercise for the reader.</p>
<h4 id="post-register">POST /register</h4>
<p>Now our first endpoint that actually does something to the database. We have two objectives here:</p>
<ol>
<li>Make sure the user isn&#39;t already registered</li>
<li>Register the user</li>
</ol>
<p>In both cases above we will redirect to the <code>POST /login</code> page afterwards to give our users the cleanest login experience (without having to re-enter their email address).</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/register&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { email } = req.<span class="hljs-property">body</span>;

  <span class="hljs-comment">// Check if a user exists</span>
  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Users</span>.<span class="hljs-property">Get</span>.<span class="hljs-title class_">ByEmail</span>(email);

  <span class="hljs-comment">// If not, create one</span>
  <span class="hljs-keyword">if</span> (users.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
      <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Users</span>.<span class="hljs-title class_">Create</span>(email);
  }

  <span class="hljs-comment">// Redirect to /login POST</span>
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-number">307</span>, <span class="hljs-string">&quot;/users/login&quot;</span>);
});
</code></pre>
<p>Another reader exercise exists above -- validate that email address before creating a user.</p>
<h4 id="post-login">POST /login</h4>
<p>This is where the one-time password gets generated and emailed to the user. First we need to make sure the appropriate libraries are imported for these actions:</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> bcrypt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;bcrypt&quot;</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">SMTPClient</span> } = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;emailjs&quot;</span>);
</code></pre>
<p>Now that we have the appropriate libraries let&#39;s create a function to handle sending the email to the user:</p>
<pre><code class="hljs language-js"><span class="hljs-comment">// Grab the environment variables</span>
<span class="hljs-keyword">const</span> { <span class="hljs-variable constant_">EMAIL_USER</span>, <span class="hljs-variable constant_">EMAIL_PASSWORD</span>, <span class="hljs-variable constant_">EMAIL_HOST</span>, <span class="hljs-variable constant_">EMAIL_FROM</span> } = process.<span class="hljs-property">env</span>;

<span class="hljs-comment">// Create an email client using emailjs</span>
<span class="hljs-keyword">const</span> client = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SMTPClient</span>({
  <span class="hljs-attr">user</span>: <span class="hljs-variable constant_">EMAIL_USER</span>,
  <span class="hljs-attr">password</span>: <span class="hljs-variable constant_">EMAIL_PASSWORD</span>,
  <span class="hljs-attr">host</span>: <span class="hljs-variable constant_">EMAIL_HOST</span>,
  <span class="hljs-attr">ssl</span>: <span class="hljs-literal">true</span>,
});

<span class="hljs-comment">// Send the email</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">sendEmail</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params">to, subject, data</span>) =&gt; {
  <span class="hljs-keyword">await</span> client.<span class="hljs-title function_">sendAsync</span>({
    <span class="hljs-attr">from</span>: <span class="hljs-variable constant_">EMAIL_FROM</span>,
    to,
    subject,
    <span class="hljs-attr">attachment</span>: [{ data, <span class="hljs-attr">alternative</span>: <span class="hljs-literal">true</span> }],
  });
};
</code></pre>
<p>The code above should be fairly straight-forward. We create an email client and then build a function that wraps sending emails. Now we just need to pass in the recipient, subject, and HTML data for the email.</p>
<p>The login step is a little more complex, we we&#39;ll go through it line-by-line to make sure everything is understood.</p>
<p>First thing is to make sure the user exists in the database:</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { email } = req.<span class="hljs-property">body</span>;

  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Users</span>.<span class="hljs-property">Get</span>.<span class="hljs-title class_">ByEmail</span>(email);

  <span class="hljs-keyword">if</span> (users.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;No user found&quot;</span> };

  <span class="hljs-comment">// There should only be one result, so grab it</span>
  <span class="hljs-keyword">const</span> user = users[<span class="hljs-number">0</span>];
});
</code></pre>
<p>A more complete app will redirect to the registration screen instead of throwing an error here.</p>
<p>Next we need to generate the one-time password. For this we&#39;ll be generating a six character alphanumeric passphrase using Node&#39;s <code>crypto</code> functions, then encrypting it for storage in the database.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-comment">// Generate OTP</span>
  <span class="hljs-keyword">const</span> code = crypto
    .<span class="hljs-title function_">randomBytes</span>(<span class="hljs-number">256</span>)
    .<span class="hljs-title function_">toString</span>(<span class="hljs-string">&quot;hex&quot;</span>)
    .<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>)
    .<span class="hljs-title function_">toUpperCase</span>();
  <span class="hljs-keyword">const</span> encrypted_code = bcrypt.<span class="hljs-title function_">hashSync</span>(code, <span class="hljs-number">10</span>);
});
</code></pre>
<p>Now that we have our code we first need to delete any preexisting OTPs to avoid any conflicts, then add the new encrypted code into the database.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-comment">// Delete any existing OTPs and insert this new one</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Otp</span>.<span class="hljs-property">Delete</span>.<span class="hljs-title class_">ById</span>(user.<span class="hljs-property">id</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Otp</span>.<span class="hljs-title class_">Create</span>(user.<span class="hljs-property">id</span>, encrypted_code);
});
</code></pre>
<blockquote>
<p>Ideally you&#39;d also run a regular cleanup on the database to delete any passcodes that are out of date.</p>
</blockquote>
<p>Our encrypted code now exists in the database, so we can email the plaintext code to the user using the function we created earlier.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-comment">// Send Email</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">sendEmail</span>(email, <span class="hljs-string">&quot;Login Code&quot;</span>, <span class="hljs-string">`Your login code is <span class="hljs-subst">${code}</span>`</span>);
});
</code></pre>
<p>Now that all this is complete we want to render our token form so the user can input the OTP when it arrives in their inbox. Make sure to include the email provided as a parameter, as it is necessary for the hidden input field as discussed previously.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/login&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">render</span>(<span class="hljs-string">&quot;token&quot;</span>, {
    email,
  });
});
</code></pre>
<h4 id="post-token">POST /token</h4>
<p>Now for the last half of the login chain -- the token. Here we need to decrypt the code in our database, compare it against the one provided by the user, and then generate a JWT for their session.</p>
<p>To start with we&#39;ll create a helper function for generating the token.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> jwt = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsonwebtoken&quot;</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title function_">makeToken</span> = (<span class="hljs-params">data</span>) =&gt; {
  <span class="hljs-keyword">const</span> expirationDate = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();
  expirationDate.<span class="hljs-title function_">setMonth</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>().<span class="hljs-title function_">getMonth</span>() + <span class="hljs-number">1</span>);
  <span class="hljs-keyword">return</span> jwt.<span class="hljs-title function_">sign</span>({ ...data, expirationDate }, process.<span class="hljs-property">env</span>.<span class="hljs-property">JWT_SECRET_KEY</span>);
};
</code></pre>
<p>This code will generate a token that lasts a month before the user will need to log in again. You can modify this token to last as long or as short as you&#39;d like. It&#39;s a balancing act between annoying the user with logins, and the security risk of a valid token existing for a long period of time.</p>
<p>Same as the login endpoint we first need to verify that a user with the provided email exists. Since we&#39;re coming from the login page this should be guaranteed, but it&#39;s always safe to validate again in case someone sends a post request directly to this endpoint and bypasses the login step.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/token&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">const</span> { email, code } = req.<span class="hljs-property">body</span>;

  <span class="hljs-keyword">const</span> users = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Users</span>.<span class="hljs-property">Get</span>.<span class="hljs-title class_">ByEmail</span>(email);

  <span class="hljs-keyword">if</span> (users.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;No user found&quot;</span> };

  <span class="hljs-comment">// There should only be one result, so grab it</span>
  <span class="hljs-keyword">const</span> user = users[<span class="hljs-number">0</span>];
});
</code></pre>
<p>Now we must get the one-time password and verify that it isn&#39;t too old. In this case &quot;too old&quot; means more than five minutes, which should give a user more than enough time to enter the code sent to their email address.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/token&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-keyword">const</span> otps = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Otp</span>.<span class="hljs-property">Get</span>.<span class="hljs-title class_">ByUserId</span>(user.<span class="hljs-property">id</span>);

  <span class="hljs-keyword">if</span> (otps.<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) {
    <span class="hljs-keyword">throw</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Login code has expired. Please request a new one.&quot;</span> };
  }

  <span class="hljs-keyword">const</span> otp = otps[<span class="hljs-number">0</span>];

  <span class="hljs-comment">// Verify the code isn&#x27;t too old</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(otp.<span class="hljs-property">created_at</span>) + <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">5</span> &lt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()) {
    <span class="hljs-keyword">throw</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Login code has expired. Please request a new one.&quot;</span>   };
  }
});
</code></pre>
<p>Now that we&#39;re sure the OTP in the database is valid we can compare it to the one provided by the user. Remember to clean up the database by deleting the code in the case that it&#39;s used successfully.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/token&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-comment">// Verify the code matches</span>
  <span class="hljs-keyword">const</span> match = bcrypt.<span class="hljs-title function_">compareSync</span>(code, otp.<span class="hljs-property">code</span>);

  <span class="hljs-keyword">if</span> (!match) <span class="hljs-keyword">throw</span> { <span class="hljs-attr">message</span>: <span class="hljs-string">&quot;Error with code&quot;</span> };
  
  <span class="hljs-comment">// Delete code</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Queries</span>.<span class="hljs-property">Otp</span>.<span class="hljs-property">Delete</span>.<span class="hljs-title class_">ByUserId</span>(user.<span class="hljs-property">id</span>);
});
</code></pre>
<p>If we&#39;ve made it this far the code provided matches the one in the database, and we can log our user in. This is where we use the <code>makeToken</code> function we created earlier to generate a JWT with our user&#39;s details.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/token&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-keyword">const</span> token = <span class="hljs-title function_">makeToken</span>({
    ...user,
  });
});
</code></pre>
<p>We have our secure token! Now we just need to store it in the user&#39;s cookies under the name <code>access_token</code> and redirect them to the <code>/account</code> page.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">post</span>(<span class="hljs-string">&quot;/token&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  ...
  
  <span class="hljs-keyword">return</span> res
    .<span class="hljs-title function_">cookie</span>(<span class="hljs-string">&quot;access_token&quot;</span>, token, {
      <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-attr">secure</span>: <span class="hljs-literal">true</span>,
    })
    .<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>)
    .<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/&quot;</span>);
});
</code></pre>
<h4 id="get-account">GET /account</h4>
<p>Our user now has a secure JWT verifying their identity. Our next step is to validate that JWT and present the user with a page that shows they are logged in.</p>
<p>First we&#39;ll create the middleware function to validate the token so that we can apply it to any endpoint we wish to be protected. The steps here are as follows:</p>
<ol>
<li>Make sure a token exists</li>
<li>Verify that it&#39;s not expired</li>
<li>Populate the user data into the request object</li>
<li>Continue to the next step in the application</li>
</ol>
<p>If any of this fails we want to redirect the user to the login screen.</p>
<pre><code class="hljs language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">validateToken</span> = (<span class="hljs-params">req, res, next</span>) =&gt; {
  <span class="hljs-keyword">const</span> token = req.<span class="hljs-property">cookies</span>.<span class="hljs-property">access_token</span>;

  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">if</span> (!token) <span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">const</span> data = jwt.<span class="hljs-title function_">verify</span>(token, process.<span class="hljs-property">env</span>.<span class="hljs-property">JWT_SECRET_KEY</span>);
    <span class="hljs-keyword">if</span> (!data.<span class="hljs-property">expirationDate</span> || <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">parse</span>(data.<span class="hljs-property">expirationDate</span>) &lt; <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()) {
      <span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>;
    }
    req.<span class="hljs-property">user</span> = {};
    <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(data).<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">key</span>) =&gt;</span> {
      req.<span class="hljs-property">user</span>[key] = data[key];
    });
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/users/login&quot;</span>);
  }
};
</code></pre>
<p>Now that we have the middleware in place we just need to use it to protect an endpoint like so:</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/account&quot;</span>, validateToken, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">`Hello <span class="hljs-subst">${req.user.name}</span>!`</span>);
});
</code></pre>
<p>This endpoint is now protected by a valid JWT, and will only render for a securely logged in user.</p>
<p>We are almost done, just one last piece of the puzzle to go.</p>
<h4 id="get-logout">GET /logout</h4>
<p>This is the simplest of all the endpoints. All we want to do is clear out the token from the cookie, and redirect them to the login page.</p>
<pre><code class="hljs language-js">router.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;/logout&quot;</span>, <span class="hljs-keyword">async</span> (req, res) =&gt; {
  <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">clearCookie</span>(<span class="hljs-string">&quot;access_token&quot;</span>).<span class="hljs-title function_">status</span>(<span class="hljs-number">200</span>).<span class="hljs-title function_">redirect</span>(<span class="hljs-string">&quot;/login&quot;</span>);
});
</code></pre>
<h2 id="summary">Summary</h2>
<p>And we&#39;re done! We have successfully created a secure registration and login system using one-time passwords. We can be sure that our data is stored securely and expires quickly enough that a data breach won&#39;t give anyone enough time or information to do anything nefarious.</p>
<p>While no system is completely secure, I hope this leaves you confident enough to implement passwordless authentication in your own applications without the risk and issues related to static passwords.</p>
<blockquote>
<p>A more complete version of this code using Handlebars for templating and express-validator for parameter validation (among other things) is available <a href="https://github.com/stevenlaidlaw/passwordless-login-express-postgres">here</a>.</p>
</blockquote>
</div>

    <footer>
      <p>
        <a href="https://github.com/stevenlaidlaw">GitHub</a>
        <span>//</span>
        <a href="https://www.linkedin.com/in/stevenglaidlaw/">LinkedIn</a>
        <span>//</span>
        <a href="https://mechanicalrock.io/">Work</a>
      </p>
      <p class="copy">Copyright <span>&copy;</span> StevenLaidlaw.com 2022</p>
    </footer>
  </body>
</html>
